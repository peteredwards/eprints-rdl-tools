#!/usr/bin/perl -w 

use strict;
use File::Basename;
use URI::Escape;
# requires Crypt::CBC and Crypt::Blowfish
use Crypt::CBC;
use MIME::Base64;
use XML::LibXML;

# max allowed file size for back-end ingestion
my $max_befsize = 10 * 1024 * 1024 * 1024;

# max allowed total back-end ingestion size
my $max_beisize = 100 * 1024 * 1024 * 1024;

my $pversion = 1; # prep file format version in case of future mods

$|=1;

# sanity check
$max_befsize = $max_beisize if $max_befsize > $max_beisize;

my $base_path = '/mnt/rdl/Repository/';
my $log_path = '/usr/share/eprints/var/';
my $datestamp = timestring();
my $log_file = $log_path . basename($0) . '_' . $datestamp . '.log';
my $prep_filename = '_rdl_ingest_ready';
my $error_filename = '_rdl_ingest_error.txt';
my $done_filename = '_rdl_ingest_completed.txt';
my %repo_name = (
	researchdata => 'RDL Live',
	rdtest => 'RDL Review'
);

my $repoid = $ARGV[0];
my $xml_file = $ARGV[1];

die "Usage:\n\t" . basename($0) . " <repo_id> <rel_path_to_xml_file>\n" if ! ( $ARGV[0] && $ARGV[1] );
die "The <repo_id> must be either 'researchdata' or 'rdtest'\n"
	if (( $repoid ne 'researchdata' ) && ( $repoid ne 'rdtest' ));

# append base path to XML file if required
$xml_file = $base_path . $xml_file if $xml_file !~ /^$base_path/;
die "Cannot find XML file '$xml_file'\n" if ! -f $xml_file; 

my $prep_file = dirname( $xml_file ) . '/' . $prep_filename;

# remove any existing prep file
unlink $prep_file if -f $prep_file;

# form the error file path and delete any existing file
my $error_file = dirname( $prep_file ) . '/' . $error_filename;
unlink $error_file if -f $error_file;

# form the done file path and delete any existing file	
my $done_file = dirname( $prep_file ) . '/' . $done_filename;

die "ERROR: a successful ingestion already appears to have been carried out from this folder.\n"
	. "       To prepare another ingestion you need to delete or rename the file '$done_filename'\n" if ( -f $done_file );

# do some output to stdio
print "Back-end ingestion preparation\n";
print "Datestamp: $datestamp\n";
print "Target repository: $repo_name{$repoid}\n";
#my $user_xml_filepath = $xml_file;
#$user_xml_filepath =~ s!^$base_path!!;
#print "Metadata XML file: $user_xml_filepath\n";
print "Metadata XML file: " . rel_path( $xml_file, $base_path, 1 ) . "\n";

# process the files referenced in the XML metadata file
my $fcheck = check_files( $xml_file, $max_befsize );

print "\n";
# error traps...
if ( $fcheck->{fmissing} )
{
	print "ERROR: The following files cannot be found: -\n";
	foreach my $mf ( @{$fcheck->{files}} )
	{
		print basename( $mf->{name} ) . "\n" if $mf->{status} eq 'missing';
	}
	print "\n";
}

elsif ( $fcheck->{foversized} )
{
	print "ERROR: The following files are too large for back-end ingestion "
				. "[max " . hr_bytes( $max_befsize, 1 ) . "] : -\n";
	foreach my $of ( @{$fcheck->{files}} )
	{
		print basename( $of->{name} ) . '   [' . hr_bytes( $of->{size}, 1 ) . "]\n"
			if $of->{status} eq 'oversized';
	}
	print "\n";
}
elsif ( $fcheck->{dunmatched} )
{
	print "ERROR: The following document 'main' values do not match a 'path' reference: -\n";
	foreach my $um ( @{$fcheck->{docs}} )
	{
		print "$um->{main}\n" if ! $um->{matched};
	}
	print "\n"
}

elsif ( $fcheck->{isize} > $max_beisize )
{
	print "ERROR: The total size of this ingestion ["
			. hr_bytes( $fcheck->{isize}, 1 ) . "] is too large.\n"
			. "Maximum permitted ingestion size is "
			. hr_bytes( $max_beisize, 1 ) . "\n\n";
}

# everything is good so write out the prep file
else
{
	open ( my $pfh, '>', $prep_file )
		or die "ERROR: cannot open prep file '$prep_file'\n";
	# human header
	print $pfh "THIS FILE IS AUTOGENERATED. DO NOT EDIT - INGESTION WILL BE ABORTED\n";
	# machine header with version
	print $pfh "$pversion\t$datestamp\t$repoid\n";
	
	# command hash
	print $pfh jbenc( "$datestamp\t$repoid\t$xml_file" ) . "\n";
	# file list
	foreach my $f ( @{$fcheck->{files}} )
	{
		#print $pfh $f->{name} . "\t" . $f->{finger} . "\t" . $f->{finger_enc} . "\n";
		print $pfh $f->{name} . "\t" . $f->{finger_enc} . "\n";
	}
	close ( $pfh );
	print "\nPreparation completed\n";
	print "\n\nPLEASE NOTE:\nIT IS ESSENTIAL THAT YOU DO NOT MAKE ANY CHANGES TO ANY"
	. " OF THE FILES ASSOCIATED WITH THIS INGESTION OTHERWISE BACK-END INGESTION WILL"
	. " BE ABORTED FOR THIS ITEM AND YOU WILL NEED TO REPEAT THIS FILE PREPARATION PROCESS.\n\n";
	
}

	
#system( "date >> $log_file" );
#open ( my $fh, '>>', $log_file );
#print $fh "Repository: $repoid\n";
#print $fh "XML file: $xml_file\n";
#close $fh;
#system( "date >> $log_file" );

sub timestring
{
	my $t = shift;
	$t = time if ! defined $t;
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t);
	return sprintf("%04d%02d%02d%02d%02d%02d", $year+1900, $mon+1, $mday, $hour, $min, $sec);
}

sub check_files
{
	my $xmlfile = shift;
	my $size_limit = shift;
	
	# some file checking parameters returned as a flattened hash ref
	my %r = (
		# ingestion level
		isize => 0,
		# eprint level
		etotal => 0,
		# doc level
		dtotal => 0,
		docs => [],
		dunmatched => 0,
		# file level
		ftotal => 0,
		ffound => 0,
		fmissing => 0,
		foversized => 0,
		fgood => 0,
		files => [],
	);

	if ( -f "$xmlfile" )
	{
		print "\nFile analysis and preparation...\n";
		print "Checking file '" . basename( $xmlfile ) . "' \n";
		my $xmlfile_finger = fingerprint( $xmlfile );
		
		# add the XML file to the list for good measure
		push @{$r{files}}, {
			name => $xmlfile,
			finger => $xmlfile_finger,
			finger_enc => jbenc( $xmlfile_finger ),
			size => -s $xmlfile,
			status => 'good',
			};

		my $x = XML::LibXML->load_xml(location => $xmlfile);

		foreach my $eprint ( $x->findnodes('eprints/eprint') )
		{
			$r{etotal}++;
			print 'Eprint: ' . $eprint->findvalue('./eprintid') . "\n";
			foreach my $doc ( $eprint->findnodes('./documents/document') )
			{
				my %d;
				$r{dtotal}++;
				$d{main} = $doc->findvalue('./main');
				#print "$d{main}\n";
				$d{matched} = 0;
				foreach my $file ( $doc->findnodes('./files/file') )
				{
					my %f;
					$r{ftotal}++;
					my $ref = $file->findvalue('./url');
					$ref =~ s/file\:\/\///g;
					my $raw_path = uri_unescape( $ref );
					print "Checking file '" . basename( $raw_path ) . "' \n";
					$f{name} = $raw_path;
					if ( -f $raw_path )
					{
						$r{ffound}++;
						$f{size} = -s $raw_path;
						$f{finger} = fingerprint( $f{name} );
						$f{finger_enc} = jbenc( $f{finger} );
						
						# sanity check the encryption - croak if issues
						die "ERROR: File analysis error. Please contact the system administrator.\n"
							if $f{finger} ne jbdec( $f{finger_enc} );
						
						#print "$raw_path $fpenc $fpdec\n";
						
						$r{isize} += $f{size};
						# check file size limit
						if ( $size_limit && ( $f{size} > $size_limit ))
						{
							$f{status} = 'oversized';
							$r{foversized}++;
						}
						else
						{
							$f{status} = 'good';
							$r{fgood}++;
						}
					}
					else
					{
							$f{status} = 'missing';
							$r{fmissing}++;
					}
					push @{$r{files}}, \%f;
					$d{matched} = 1 if $d{main} eq basename( $raw_path );
				}
				if ( ! $d{matched} )
				{
					$r{dunmatched}++;
					#$r{errors}++;
					#$r{error_str} .= "ERROR: main '$main' does not match any file path\n";
				}
				push @{$r{docs}}, \%d;
			}
		}
		return \%r;
	}
	else
	{
		die "XML metadata file '$xmlfile' not found\n";
	}
}

# return a "fingerprint" string for a file consisting of mod time and size
# which we will will subsequently encrypt
# we don't do MD5 hash of file because it takes too long on large files
# we could do MD5 hash of just the mod date/size string but don't do this
# since MD5 is one-way so doesn't allow any post error analysis
sub fingerprint
{
	my $file = shift;
	
	return undef if ! -f $file;

	my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
		$atime,$mtime,$ctime,$blksize,$blocks) = stat($file);
	my $fstring = timestring( $mtime ) . sprintf( "%015d", $size );
	#my $fstring = timestring( $mtime ) . $size;

	return $fstring;
}


sub jbenc
{
	my $ptext = shift;
	
	return undef if ! defined $ptext;
	
	my $cipher = Crypt::CBC->new(
		-key => 'RDLBEingest',
		-cipher => 'Blowfish',
		-keysize => 16
	);

	my $cbytes = $cipher->encrypt( $ptext );
	
	# remove salt header
	$cbytes =~ s!Salted__!!g;

	# return a BF encoded hex string  
	return join( '', map( sprintf( "%02x", ord ), split( //, $cbytes ) ) );
}


sub jbdec
{
	my $cipherhex = shift;
	
	return undef if $cipherhex !~ /^(?:[a-fA-F0-9]{2})+$/;
	
	my $cbytes = $cipherhex;
	$cbytes =~ s/([a-fA-F0-9][a-fA-F0-9])/chr(hex($1))/eg;
	
	# add the salt header
	$cbytes = 'Salted__' . $cbytes;
	
	my $cipher = Crypt::CBC->new(
		-key => 'RDLBEingest',
		-cipher => 'Blowfish',
		-keysize => 16
	);
	my $ptext = $cipher->decrypt( $cbytes );
	
	return $ptext;
}

# pretty print a byte number in units of 1024 - and show raw bytes too if show_bytes flag is set
sub hr_bytes
{
	my $rawb = shift;
	my $show_bytes = shift || 0;
	
	return '' if $rawb !~ /^[0-9]+$/;
	
	my $modb = $rawb;

	foreach ( 'bytes', 'KB', 'MB', 'GB', 'TB', 'PB' )
	{
		if ( $modb < 1024 )
		{
			my $op = sprintf("%.0f ",$modb)."$_";
			$op .= " ($rawb bytes)" if ( $show_bytes && $rawb > 1023 );
			return $op;
		}
		$modb /= 1024;
	}
}

# print file path without base path and swap to backslashes if windows mode
sub rel_path
{
	my ( $path, $base, $windows ) = @_;
	
	# remove base path if it is present
	$path =~ s!^$base!!;
	$path =~ s!/!\\!g if $windows;
	
	return $path;
}

# TO DO - main/path check (also in excel.pl)??
